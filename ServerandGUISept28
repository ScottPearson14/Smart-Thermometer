#!/usr/bin/env python3
"""
Merged Flask + Tkinter GUI for Smart Thermometer
- Runs Flask server in a background thread.
- Stores incoming temperature posts in a thread-safe queue.
- Tkinter GUI reads latest queue item once per second and updates
  the 300s rolling history and the live graph.
  
Usage:
    python merged_therm_gui.py
Ensure your ESP32 posts to http://<this_machine_ip>:8080/data
"""

from flask import Flask, request, jsonify
from datetime import datetime
import threading
import queue
import time
import math
import collections
import tkinter as tk
from tkinter import ttk
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg

# --- Requirements and Constants ---
GRAPH_TIME_SPAN = 300          # seconds to keep on graph
UPDATE_INTERVAL_MS = 1000     # GUI update interval in ms (1s)
TEMP_C_MAX = 50
TEMP_C_MIN = 10

# Thread-safe queue to pass data from Flask -> GUI
data_queue = queue.Queue()

# For deciding if third box is on/off (no data means off)
THIRD_BOX_TIMEOUT_S = 2.0  # if no posts within this, treat as off

# -----------------------------
# Flask server (background)
# -----------------------------
app = Flask(__name__)

@app.route('/')
def home():
    return "ESP32 Temperature Server is running!"

@app.route('/test')
def test_endpoint():
    return jsonify({"message": "Server is running!", "timestamp": datetime.now().isoformat()})

@app.route('/data', methods=['POST'])
def receive_data():
    try:
        data = request.json or {}
        # The ESP32 sends temp1/temp2 as numbers or null.
        temp1 = data.get("temp1", None)
        temp2 = data.get("temp2", None)
        esp_ts = data.get("timestamp", None)

        # stamp server receive time
        received_time = time.time()
        human_ts = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

        # Log to console
        print(f"[{human_ts}] Received data from ESP32: temp1={temp1}, temp2={temp2}, esp_ts={esp_ts}")

        # Push to queue (latest entry)
        data_queue.put({
            "temp1": temp1,
            "temp2": temp2,
            "esp_timestamp": esp_ts,
            "server_recv_time": received_time
        })

        return jsonify({"status": "success"}), 200

    except Exception as e:
        print(f"Error processing request: {e}")
        return jsonify({"status": "error", "message": str(e)}), 400


def run_flask_server():
    # Important: disable the reloader when using Flask in a thread
    app.run(host='0.0.0.0', port=8080, debug=False, use_reloader=False, threaded=True)


# -----------------------------
# GUI + Plotting
# -----------------------------
class SmartThermometerGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("Smart Thermometer GUI (Merged Server + GUI)")

        # Current temps (last known)
        self.temps_c = {1: 22.0, 2: 22.0}  # initial guess
        # Sensors enabled (controlled by ESP posting null or value)
        self.sensors_enabled = {1: False, 2: False}
        # third_box_on derived from receive activity
        self.third_box_on = False
        self.last_recv_time = 0.0

        # history deques (most recent value appended right)
        nan_init = float('nan')
        self.history_1 = collections.deque([nan_init] * GRAPH_TIME_SPAN, maxlen=GRAPH_TIME_SPAN)
        self.history_2 = collections.deque([nan_init] * GRAPH_TIME_SPAN, maxlen=GRAPH_TIME_SPAN)

        # GUI widgets
        self.create_widgets()
        self.setup_graph()

        # Start periodic GUI update
        self.root.after(UPDATE_INTERVAL_MS, self.periodic_update)

    def create_widgets(self):
        control_frame = ttk.LabelFrame(self.root, text="System Control & Real-Time Data")
        control_frame.pack(padx=10, pady=10, fill="x")

        self.third_box_switch_var = tk.BooleanVar(value=True)
        # This checkbox simulates local "third box" on/off. It does not override real hardware:
        # if hardware says off (no posts), GUI will show no data. This checkbutton is left as a stub.
        self.third_box_switch = ttk.Checkbutton(control_frame, text="Third Box Sim (stub)", variable=self.third_box_switch_var, command=self.toggle_third_box)
        self.third_box_switch.grid(row=0, column=0, padx=5, pady=5)

        self.unit_button = ttk.Button(control_frame, text="Switch to 째F", command=self.toggle_units)
        self.unit_button.grid(row=0, column=1, padx=5, pady=5)
        self.display_units = 'C'  # 'C' or 'F'

        self.temp_label_1 = ttk.Label(control_frame, text="Sensor 1: ---", font=('Helvetica', 18, 'bold'))
        self.temp_label_1.grid(row=1, column=0, padx=10, pady=6, sticky="W")

        self.temp_label_2 = ttk.Label(control_frame, text="Sensor 2: ---", font=('Helvetica', 18, 'bold'))
        self.temp_label_2.grid(row=2, column=0, padx=10, pady=6, sticky="W")

        # Buttons left as stubs (per your request)
        self.toggle_button_1 = ttk.Button(control_frame, text="Toggle Sensor 1 (stub)", command=lambda: self.toggle_sensor(1))
        self.toggle_button_1.grid(row=1, column=1, padx=5, pady=5)

        self.toggle_button_2 = ttk.Button(control_frame, text="Toggle Sensor 2 (stub)", command=lambda: self.toggle_sensor(2))
        self.toggle_button_2.grid(row=2, column=1, padx=5, pady=5)

    def setup_graph(self):
        graph_frame = ttk.LabelFrame(self.root, text="Temperature Graph (Last 300 Seconds)")
        graph_frame.pack(padx=10, pady=10, fill="both", expand=True)

        self.fig, self.ax = plt.subplots(figsize=(9, 4))
        self.canvas = FigureCanvasTkAgg(self.fig, master=graph_frame)
        self.canvas_widget = self.canvas.get_tk_widget()
        self.canvas_widget.pack(fill=tk.BOTH, expand=True)

        # initial axis settings
        self.ax.set_ylim(TEMP_C_MIN, TEMP_C_MAX)
        self.ax.set_xlim(GRAPH_TIME_SPAN, 0)
        self.ax.set_ylabel("Temp, 째C")
        self.ax.set_xlabel("Seconds ago")
        self.ax.set_title("Temperature History")
        self.legend = None

    # Called every second by Tkinter .after
    def periodic_update(self):
        """
        1) Drain the queue for the latest message (if any).
        2) Update sensors_enabled, temps, last_recv_time.
        3) Append either new values (if received) or NaN to the history buffers.
        4) Update labels and redraw graph.
        """
        got_message = False
        latest_msg = None
        # Drain the queue, keep the most recent message
        while True:
            try:
                msg = data_queue.get_nowait()
                latest_msg = msg
                got_message = True
            except queue.Empty:
                break

        if got_message and latest_msg is not None:
            # Use latest message only (since updates are once/sec from ESP32)
            t1 = latest_msg.get("temp1", None)
            t2 = latest_msg.get("temp2", None)
            self.last_recv_time = latest_msg.get("server_recv_time", time.time())

            # If posted null -> sensor unplugged -> mark disabled; else enabled
            if t1 is None:
                self.sensors_enabled[1] = False
            else:
                # ensure it's a float
                try:
                    self.temps_c[1] = float(t1)
                except Exception:
                    # leave previous value if conversion fails
                    pass
                self.sensors_enabled[1] = True

            if t2 is None:
                self.sensors_enabled[2] = False
            else:
                try:
                    self.temps_c[2] = float(t2)
                except Exception:
                    pass
                self.sensors_enabled[2] = True

            # mark third box on (we have data)
            self.third_box_on = True

            # Append to history: if sensor enabled add reading, else NaN
            self.history_1.append(self.temps_c[1] if self.sensors_enabled[1] else float('nan'))
            self.history_2.append(self.temps_c[2] if self.sensors_enabled[2] else float('nan'))

        else:
            # No message this second
            now = time.time()
            # if last receive too old, consider third box off
            if now - self.last_recv_time > THIRD_BOX_TIMEOUT_S:
                self.third_box_on = False
            # append missing (NaN) to both histories (graph must continue to scroll)
            self.history_1.append(float('nan'))
            self.history_2.append(float('nan'))

        # Update textual labels based on state
        if not self.third_box_on:
            self.temp_label_1.config(text="No data available")
            self.temp_label_2.config(text="No data available")
        else:
            # Sensor 1
            if self.sensors_enabled[1]:
                temp = self.temps_c[1]
                if self.display_units == 'F':
                    temp = self.c_to_f(temp)
                self.temp_label_1.config(text=f"Sensor 1: {temp:.2f}째{self.display_units}")
            else:
                self.temp_label_1.config(text="Sensor 1: OFF")
            # Sensor 2
            if self.sensors_enabled[2]:
                temp = self.temps_c[2]
                if self.display_units == 'F':
                    temp = self.c_to_f(temp)
                self.temp_label_2.config(text=f"Sensor 2: {temp:.2f}째{self.display_units}")
            else:
                self.temp_label_2.config(text="Sensor 2: OFF")

        # Redraw graph using current histories
        self.redraw_graph()

        # schedule next update
        self.root.after(UPDATE_INTERVAL_MS, self.periodic_update)

    def redraw_graph(self):
        # Prepare data
        y1 = list(self.history_1)
        y2 = list(self.history_2)
        x = list(range(GRAPH_TIME_SPAN, 0, -1))  # seconds ago from 300 -> 1

        # Convert to Fahrenheit if needed for plotting while preserving NaNs
        if self.display_units == 'F':
            y1 = [self.c_to_f(v) if (v is not None and not math.isnan(v)) else float('nan') for v in y1]
            y2 = [self.c_to_f(v) if (v is not None and not math.isnan(v)) else float('nan') for v in y2]
            self.ax.set_ylabel("Temp, 째F")
            self.ax.set_ylim(self.c_to_f(TEMP_C_MIN), self.c_to_f(TEMP_C_MAX))
        else:
            self.ax.set_ylabel("Temp, 째C")
            self.ax.set_ylim(TEMP_C_MIN, TEMP_C_MAX)

        # Clear and redraw
        self.ax.cla()
        self.ax.set_xlim(GRAPH_TIME_SPAN, 0)
        self.ax.set_xlabel("Seconds ago")
        self.ax.set_title("Temperature History")
        self.ax.set_ylabel(self.ax.get_ylabel())

        # Plot continuous segments for each sensor so missing data shows as gaps
        def plot_segments(x_vals, y_vals, label):
            seg_x = []
            seg_y = []
            for xi, yi in zip(x_vals, y_vals):
                missing = (yi is None) or (isinstance(yi, float) and math.isnan(yi))
                if not missing:
                    seg_x.append(xi)
                    seg_y.append(yi)
                else:
                    if seg_x:
                        self.ax.plot(seg_x, seg_y, linewidth=1.5, label=label if label else "")
                        seg_x = []
                        seg_y = []
                        # After the first plotted segment, clear the label (so legend not repeated)
                        label = ""
            if seg_x:
                self.ax.plot(seg_x, seg_y, linewidth=1.5, label=label)
        
        plot_segments(x, y1, "Sensor 1")
        plot_segments(x, y2, "Sensor 2")

        # Legend only once
        self.ax.legend(loc='upper right')
        self.ax.grid(True)
        # Draw on canvas
        self.canvas.draw_idle()

    def toggle_units(self):
        if self.display_units == 'C':
            self.display_units = 'F'
            self.unit_button.config(text="Switch to 째C")
        else:
            self.display_units = 'C'
            self.unit_button.config(text="Switch to 째F")

    def toggle_third_box(self):
        # This is a stub control. The real third_box_on depends on ESP posts.
        v = self.third_box_switch_var.get()
        print(f"(Stub) Third box sim set to {v}")

    def toggle_sensor(self, sensor_num):
        # Left as a stub to avoid interfering with real hardware button behavior.
        self.sensors_enabled[sensor_num] = not self.sensors_enabled[sensor_num]
        print(f"(Stub) Sensor {sensor_num} toggled to {'ON' if self.sensors_enabled[sensor_num] else 'OFF'}")

    @staticmethod
    def c_to_f(celsius):
        return (celsius * 9/5) + 32


# -----------------------------
# Main startup
# -----------------------------
def main():
    # Start Flask in background thread
    flask_thread = threading.Thread(target=run_flask_server, daemon=True)
    flask_thread.start()
    print("Flask server thread started on port 8080.")

    # Start Tkinter GUI on main thread
    root = tk.Tk()
    gui = SmartThermometerGUI(root)
    print("Starting GUI mainloop...")
    root.mainloop()
    print("GUI closed. Exiting.")


if __name__ == "__main__":
    main()
